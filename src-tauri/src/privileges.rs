use windows_sys::Win32::Foundation::{GetLastError, LUID, CloseHandle};
use windows_sys::Win32::Security::{
    AdjustTokenPrivileges, LookupPrivilegeValueW, TOKEN_ADJUST_PRIVILEGES, TOKEN_PRIVILEGES,
    TOKEN_QUERY, SE_PRIVILEGE_ENABLED, LUID_AND_ATTRIBUTES,
};
use windows_sys::Win32::System::Threading::{GetCurrentProcess, OpenProcessToken};
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;

/// Enable a specific Windows privilege for the current process
fn enable_privilege(privilege_name: &str, token_handle: isize) -> Result<(), String> {
    unsafe {
        let mut luid: LUID = std::mem::zeroed();
        let name_wide: Vec<u16> = OsStr::new(privilege_name)
            .encode_wide()
            .chain(std::iter::once(0))
            .collect();

        if LookupPrivilegeValueW(std::ptr::null(), name_wide.as_ptr(), &mut luid) == 0 {
            return Err(format!("LookupPrivilegeValueW failed for {}: {}", privilege_name, GetLastError()));
        }

        let mut token_privileges = TOKEN_PRIVILEGES {
            PrivilegeCount: 1,
            Privileges: [LUID_AND_ATTRIBUTES {
                Luid: luid,
                Attributes: SE_PRIVILEGE_ENABLED,
            }],
        };

        if AdjustTokenPrivileges(
            token_handle,
            0,
            &mut token_privileges,
            0,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
        ) == 0
        {
            return Err(format!("AdjustTokenPrivileges failed for {}: {}", privilege_name, GetLastError()));
        }
        
        let err = GetLastError();
        if err != 0 {
             // 1300 = ERROR_NOT_ALL_ASSIGNED
             if err == 1300 {
                 return Err(format!("{}: ERROR_NOT_ALL_ASSIGNED (權限未被授予)", privilege_name));
             }
        }
    }

    Ok(())
}

/// Enable all privileges required for WireGuard to create named pipes in protected namespace
pub fn enable_se_restore_privilege() -> Result<(), String> {
    unsafe {
        let mut token_handle = 0;
        let process_handle = GetCurrentProcess();
        
        if OpenProcessToken(process_handle, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &mut token_handle) == 0 {
            return Err(format!("OpenProcessToken failed: {}", GetLastError()));
        }

        // List of privileges required for WireGuard named pipe access
        // SeRestorePrivilege: Required for certain file operations
        // SeBackupPrivilege: Required for backup operations and protected namespace access
        // SeCreateSymbolicLinkPrivilege: Often required for protected pipes
        // SeSecurityPrivilege: Required for accessing security descriptors
        let required_privileges = [
            "SeRestorePrivilege",
            "SeBackupPrivilege", 
            "SeCreateSymbolicLinkPrivilege",
            "SeSecurityPrivilege",
        ];

        let mut errors = Vec::new();
        let mut success_count = 0;

        for privilege in &required_privileges {
            match enable_privilege(privilege, token_handle) {
                Ok(_) => {
                    println!("✓ 已啟用權限: {}", privilege);
                    success_count += 1;
                }
                Err(e) => {
                    println!("✗ 無法啟用權限 {}: {}", privilege, e);
                    errors.push(format!("{}: {}", privilege, e));
                }
            }
        }

        // Clean up
        CloseHandle(token_handle);

        // Return error only if ALL privileges failed
        if success_count == 0 {
            return Err(format!("所有權限啟用失敗:\n{}", errors.join("\n")));
        }

        // Warn if some privileges failed but at least one succeeded
        if !errors.is_empty() {
            println!("警告: {} 個權限啟用失敗，但已啟用 {} 個，嘗試繼續...", 
                     errors.len(), success_count);
        }

        Ok(())
    }
}
